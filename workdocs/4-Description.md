### Description

This module focuses on the chaincode (contracts) side of @decaf-ts/for-fabric. It adapts DECAF’s Repository/Model/Adapter abstractions to Hyperledger Fabric’s world state and execution context so you can implement smart contracts with familiar patterns and minimal boilerplate.

Key ideas:
- Keep your domain models as annotated classes (using @decaf-ts/decorator-validation).
- Use a Repository to persist/read/query models through a Fabric-aware Adapter.
- Compose reusable CRUD contracts and utilities instead of hand-writing stub calls.
- Emit first-class Fabric events from repository operations.
- Leverage context-aware logging and typed flags during execution.

Contracts building blocks identified in src/contracts:

1) Core context and types
- FabricContractContext: Extends the generic Context to expose Fabric-specific properties (stub, clientIdentity, logger) and timestamp resolution from the ledger.
- FabricContractFlags: Interface extending RepositoryFlags with stub, clientIdentity and logger for contract calls.

2) Logging
- ContractLogger: MiniLogger-compatible logger bound to the Fabric contract Context. It honors log levels and forwards to the underlying Fabric logger.

3) Adapter and repository
- FabricContractAdapter: Chaincode-side Adapter that implements CRUD, bulk operations, raw Mango queries, result iteration, model preparation/reversion, composite-key prefixes, and sequence creation. Bridges DECAF abstractions to Fabric (ChaincodeStub, ClientIdentity) and CouchDB-style queries.
- FabricContractRepository<M>: Repository for models inside chaincode. Supports create, update, createAll, updateAll, read/readAll, raw queries (Mango), select projections, prefix-based bulk ops, and event emission through an ObserverHandler.
- FabricContractRepositoryObservableHandler: ObserverHandler that emits Fabric events via stub.setEvent using names generated by generateFabricEventName.

4) Sequences
- FabricContractDBSequence: Fabric-backed implementation of Sequence with current, next and range. Stores values in the world state via FabricContractRepository and supports Number or BigInt sequences with configurable startWith and incrementBy.

5) CRUD contracts
- FabricCrudContract<M>: Base smart contract exposing CRUD endpoints (create, read, update, delete, createAll, readAll, updateAll, deleteAll, raw, init, healthcheck) for a model type. Uses DeterministicSerializer and the FabricContractAdapter/Repository behind the scenes and provides logFor(ctx).
- SerializedCrudContract<M>: Same endpoints as FabricCrudContract but takes/returns JSON strings (de)serialized to the model class. This simplifies client interactions and is used in tests.

6) ERC20 sample
- ERC20Token, ERC20Wallet, Allowance: Sample domain models for an ERC20-like token, wallets and allowances.
- FabricStatement<M,R>: A CouchDBStatement bridge that runs Mango queries through FabricContractAdapter, handling primary key projection when needed.
- FabricERC20Contract: A full ERC20 smart contract showcasing repository-based persistence and arithmetic helpers. Implements Initialize, CheckInitialized, TokenName, Symbol, Decimals, TotalSupply, BalanceOf, Transfer, TransferFrom, Approve, Allowance, Mint, Burn, BurnFrom, ClientAccountBalance, ClientAccountID and an internal _transfer helper.

Design notes:
- Deterministic serialization is used to ensure stable bytes for world-state writes.
- onCreate/onCreateUpdate hooks from db-decorators are leveraged by the adapter to set primary keys and creator/owner metadata.
- Mango queries (CouchDB) are used for rich queries via getQueryResultWithPagination.
- Event emission is opt-in per operation type through FabricContractRepositoryObservableHandler’s supportedEvents list.

With these components you can build robust chaincode while keeping code concise, testable, and aligned with DECAF’s architecture.
